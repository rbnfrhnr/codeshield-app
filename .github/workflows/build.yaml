name: Build & Semantic Release

on:
  push:
    branches:
      - main
      - staging

jobs:
  release:
    name: Build, Release, and Dockerize
    runs-on: ubuntu-latest

    env:
      PYTHON_VERSION: '3.11'
      NODE_VERSION: '20'
      DOCKER_REGISTRY: env-rbnfrhnrtest-registry.jcloud.ik-server.com
      IMAGE_NAME: codeshield-app

    steps:
      # Checkout source code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # required for semantic-release to analyze commits

      # Set up Python & Poetry
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: poetry install --no-interaction

      # Set up Node.js & semantic-release
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install semantic-release and plugins
        run: |
          npm install -g semantic-release \
            @semantic-release/git \
            @semantic-release/changelog \
            @semantic-release/exec

      - name: Run semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release

      # Build Python package
      - name: Build Python wheel
        run: |
          poetry build
          mkdir -p build
          cp dist/*.whl build/

      - name: Extract version from wheel filename
        id: extract_version
        run: |
          WHEEL_FILE=$(ls dist/*.whl | head -n 1)
          VERSION=$(basename "$WHEEL_FILE" | sed -E 's/^[^-]+-([^-]+)-.*$/\1/')
          echo "PACKAGE_VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      # GitHub Release
      - name: Upload wheel to GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.extract_version.outputs.version }}
          name: Release v${{ steps.extract_version.outputs.version }}
          files: build/*.whl
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Docker build & push
      - name: Build, Tag & Push Docker Image
        run: |
          VERSION=${{ steps.extract_version.outputs.version }}
          IMAGE=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}

          echo "Building Docker image: $IMAGE:$VERSION"
          docker build -t $IMAGE:$VERSION .

          # Push version tag
          docker push $IMAGE:$VERSION

          # Tag as latest or latest-rc
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            docker tag $IMAGE:$VERSION $IMAGE:latest
            docker push $IMAGE:latest
          elif [[ "${GITHUB_REF##*/}" == "staging" ]]; then
            docker tag $IMAGE:$VERSION $IMAGE:latest-rc
            docker push $IMAGE:latest-rc
          fi


      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure Kubeconfig
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            echo "${{ secrets.KUBECONFIG_MAIN }}" > ~/.kube/config
          elif [[ "${GITHUB_REF##*/}" == "staging" ]]; then
            echo "${{ secrets.KUBECONFIG_STAGING }}" > ~/.kube/config
          else
            echo "Unsupported branch for kubeconfig"
            exit 1
          fi
          chmod 600 ~/.kube/config

      - name: Deploy to Kubernetes
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            DEPLOYMENT_FILE="k8s/main/deployment.yaml"
          elif [[ "${GITHUB_REF##*/}" == "staging" ]]; then
            DEPLOYMENT_FILE="k8s/staging/deployment.yaml"
          else
            echo "Unknown branch, skipping deploy"
            exit 0
          fi

          echo "Updating  $DEPLOYMENT_FILE"
          kubectl apply -f "$DEPLOYMENT_FILE"